unit uCodeGen;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, ubackend, dateutils, ucode, uGenericInterfaces, umessages,
  uTypesImpl, uDefinitionImpl, uLocals, uDirective, uInstruction, uPredefined;

type

  { TCodeGenerator }

  TCodeGenerator = class(TBackEnd)
    private
      class var
        AssemblyFile: TStringList;
        InstructionCount: integer;
    protected
      const TAB = #9;
      class var
        ProgramName: string;
      var
        LocalVariables: TLocalVariables;
        LocalStack: TLocalStack;
    public
      constructor Create;
      constructor Create(Parent: TCodeGenerator);
      procedure Process(AICode: IIntermediateCode;
        ASymtabStack: ISymtabStack); override;
      procedure Generate(Node: ICodeNode); virtual;
      procedure Generate(RoutineID: ISymTabEntry); virtual;
    protected
      procedure EmitBlankLine;
      procedure EmitLabel(ALabel: TLabel);
      procedure EmitLabel(Value: Integer; ALabel: TLabel);
      procedure EmitLabel(Value: String; ALabel: TLabel);

      procedure EmitDirective(Directive: TDirective);
      procedure EmitDirective(Directive: TDirective; Operand: String);
      procedure EmitDirective(Directive: TDirective; Operand: Integer);
      procedure EmitDirective(Directive: TDirective; Operand1, Operand2: String);
      procedure EmitDirective(Directive: TDirective;
        Operand1, Operand2, Operand3: String);

      procedure Emit(Opcode: TInstruction);
      procedure Emit(Opcode: TInstruction; Operand: String);
      procedure Emit(Opcode: TInstruction; Operand: Integer);
      procedure Emit(Opcode: TInstruction; Operand: Double);
      procedure Emit(Opcode: TInstruction; ALabel: TLabel);
      procedure Emit(Opcode: TInstruction; Operand1, Operand2: Integer);
      procedure Emit(Opcode: TInstruction; Operand1, Operand2: String);
      //Loads
      procedure EmitLoadConstant(Value: Integer);
      procedure EmitLoadConstant(Value: Double);
      procedure EmitLoadConstant(Value: String);
      procedure EmitLoadLocal(Typ: ITypeSpec; Index: Integer);
      procedure EmitLoadVariable(VariableID: ISymTabEntry);
      procedure EmitLoadArrayElement(elmtType: ITypeSpec);
      //Stores
      procedure EmitStoreLocal(Typ: ITypeSpec; Index: Integer);
      procedure EmitStoreVariable(VariableID: ISymTabEntry);
      procedure EmitStoreVariable(VariableID: ISymTabEntry;
        NestingLevel, Index: Integer);
      procedure EmitStoreArrayElement(elmtType: ITypeSpec);
      //Miscellaneous emitters
      procedure EmitCheckCast(Typ: ITypeSpec);
      procedure EmitCheckCastClass(Typ: ITypeSpec);
      procedure EmitReturnValue(Typ: ITypeSpec);
      procedure EmitRangeCheck(TargetType: ITypeSpec);
      //utilities
      function TypeDescriptor(ID: ISymTabEntry): String;
      function TypeDescriptor(Typ: ITypeSpec): String;
      function javaTypeDescriptor(Typ: ITypeSpec): String;
      function isStructured(Typ: ITypeSpec): Boolean;
      function isWrapped(VariableID: ISymTabEntry): Boolean;
      function needsCloning(FormalID: ISymTabEntry): Boolean;
      function ValueOfSignature(Typ: ITypeSpec): String;
      function ValueSignature(Typ: ITypeSpec): String;
      function VarParmWrapper(Typ: ITypeSpec): String;
  end;

implementation
uses uObjectUtils, uSymtabImpl;

{ TCodeGenerator }

constructor TCodeGenerator.Create;
begin
  //nothing
end;

constructor TCodeGenerator.Create(Parent: TCodeGenerator);
begin
  Inherited Create;
  LocalVariables := Parent.LocalVariables;
  LocalStack := Parent.LocalStack;
end;

// Process the intermediate code and the symbol table generated by the
// parser to generate machine-language instructions.
procedure TCodeGenerator.Process(AICode: IIntermediateCode;
  ASymtabStack: ISymtabStack);
var
  StartTime: TDateTime;
  ElapsedTime: Double;
  ProgramID: ISymTabEntry;
  ProgName, AssemblyFileName: String;
  ProgramGenerator: TCodeGenerator;
begin
  SymTabStack := ASymtabStack;

  StartTime := TimeOf(Now);

  ProgramID := SymTabStack.getProgramID;
  ProgName := ProgramID.getName;
  AssemblyFileName := ProgName + '.j';
  //Open a new assembly file for writing
  AssemblyFile := TStringList.Create;
  try
    //Generate code for the main program.
    ProgramGenerator := TCodeGenerator.Create(Self);
    ProgramGenerator.Generate(AICode.getRoot);

    AssemblyFile.SaveToFile(AssemblyFileName);
  finally
    AssemblyFile.Free;
  end;

  ElapsedTime := SecondSpan(StartTime, TimeOf(Now));

  SendMessage(TMessage.Create(mtCompilerSummary,
    TCompilerSummaryMsg.Create(InstructionCount, ElapsedTime)));

end;

//Generate code for a statement.
procedure TCodeGenerator.Generate(Node: ICodeNode);
begin
 //to be overridden by the code generator subclasses.
end;

//Generate code for a routine.
procedure TCodeGenerator.Generate(RoutineID: ISymTabEntry);
begin
  //to be overridden by the code generator subclasses.
end;

//=====================
//GENERAL CODE EMITTERS
//=====================

//Emit a blank line
procedure TCodeGenerator.EmitBlankLine;
begin
  AssemblyFile.Add('');
end;

//Emit a label
procedure TCodeGenerator.EmitLabel(ALabel: TLabel);
begin
  AssemblyFile.Add(ALabel.toString + ':');
end;

//Emit a label preceded by an integer value for a switch table
procedure TCodeGenerator.EmitLabel(Value: Integer; ALabel: TLabel);
begin
  AssemblyFile.Add(TAB + IntToStr(Value) + ':' + ALabel.toString);
end;

//Emit a label preceded by an string value for a switch table
procedure TCodeGenerator.EmitLabel(Value: String; ALabel: TLabel);
begin
  AssemblyFile.Add(TAB + Value + ':' + ALabel.toString);
end;

//Emit a directive.
procedure TCodeGenerator.EmitDirective(Directive: TDirective);
begin
  AssemblyFile.Add(Directive.toString);
  Inc(InstructionCount);
end;

//Emit a 1-operand directive.
procedure TCodeGenerator.EmitDirective(Directive: TDirective; Operand: String);
begin
  AssemblyFile.Add(Directive.toString + ' ' + Operand);
  Inc(InstructionCount);
end;

//Emit a 1-operand directive.
procedure TCodeGenerator.EmitDirective(Directive: TDirective; Operand: Integer);
begin
  AssemblyFile.Add(Directive.toString + ' ' + IntToStr(Operand));
  Inc(InstructionCount);
end;

//Emit a 2-operand directive.
procedure TCodeGenerator.EmitDirective
  (Directive: TDirective; Operand1, Operand2: String);
begin
  AssemblyFile.Add(Directive.toString + ' ' + Operand1 + ' ' + Operand2);
  Inc(InstructionCount);
end;

//Emit a 3-operand directive.
procedure TCodeGenerator.EmitDirective
  (Directive: TDirective; Operand1, Operand2, Operand3: String);
begin
  AssemblyFile.Add(
    Directive.toString + ' ' + Operand1 + ' ' + Operand2 + ' ' + Operand3);
  Inc(InstructionCount);
end;

//Emit a 0-operand instruction
procedure TCodeGenerator.Emit(Opcode: TInstruction);
begin
  AssemblyFile.Add(TAB + Opcode.toString);
  Inc(InstructionCount);
end;

//Emit a 1-operand instruction
procedure TCodeGenerator.Emit(Opcode: TInstruction; Operand: String);
begin
  AssemblyFile.Add(TAB + Opcode.toString + TAB + Operand);
  Inc(InstructionCount);
end;

//Emit a 1-operand instruction
procedure TCodeGenerator.Emit(Opcode: TInstruction; Operand: Integer);
begin
  AssemblyFile.Add(TAB + Opcode.toString + TAB + IntToStr(Operand));
  Inc(InstructionCount);
end;

//Emit a 1-operand instruction
procedure TCodeGenerator.Emit(Opcode: TInstruction; Operand: Double);
begin
  AssemblyFile.Add(TAB + Opcode.toString + TAB + FloatToStr(Operand));
  Inc(InstructionCount);
end;

//Emit a 1-operand instruction
procedure TCodeGenerator.Emit(Opcode: TInstruction; ALabel: TLabel);
begin
  AssemblyFile.Add(TAB + Opcode.toString + TAB + ALabel.toString);
  Inc(InstructionCount);
end;

//Emit a 2-operand instruction
procedure TCodeGenerator.Emit(Opcode: TInstruction; Operand1, Operand2: Integer
  );
begin
  AssemblyFile.Add(
    TAB + Opcode.toString + TAB + IntToStr(Operand1) + ' ' + IntToStr(Operand2));
  Inc(InstructionCount);
end;

//Emit a 2-operand instruction
procedure TCodeGenerator.Emit(Opcode: TInstruction; Operand1, Operand2: String);
begin
  AssemblyFile.Add(TAB + Opcode.toString + TAB + Operand1 + ' ' + Operand2);
  Inc(InstructionCount);
end;

//Emit a load of an Integer constant value
procedure TCodeGenerator.EmitLoadConstant(Value: Integer);
begin
  case Value of
    -1: Emit(_ICONST_M1);
    0 : Emit(_ICONST_0);
    1 : Emit(_ICONST_1);
    2 : Emit(_ICONST_2);
    3 : Emit(_ICONST_3);
    4 : Emit(_ICONST_4);
    5 : Emit(_ICONST_5);
    else
      if (-128 <= Value) and (Value <= 127) then
        Emit(_BIPUSH, Value)
      else if (-32768 <= Value) and (Value <= 32767) then
        Emit(_SIPUSH, Value)
      else
        Emit(_LDC, Value);
  end;
end;

//Emit a load of an Float constant value
procedure TCodeGenerator.EmitLoadConstant(Value: Double);
begin
  if Value = 0.0 then
    Emit(_FCONST_0)
  else if Value = 1.0 then
    Emit(_FCONST_1)
  else if Value = 2.0 then
    Emit(_FCONST_2)
  else
    Emit(_LDC, Value);
end;

//Emit a load of an String constant value
procedure TCodeGenerator.EmitLoadConstant(Value: String);
begin
  Emit(_LDC, '\' + Value + '\');
end;

//Emit a load instruction for a local variable
procedure TCodeGenerator.EmitLoadLocal(Typ: ITypeSpec; Index: Integer);
var
  Form: ITypeForm = Nil;
begin
  if Typ <> Nil then begin
    Typ := Typ.baseType;
    Form := Typ.getForm;
  end;
  if (Typ = TPredefined.integerType) or (Typ = TPredefined.booleanType) or
     (Typ = TPredefined.charType) or (Form = tfEnumeration) then
  begin
    case Index of
      0: Emit(_ILOAD_0);
      1: Emit(_ILOAD_1);
      2: Emit(_ILOAD_2);
      3: Emit(_ILOAD_3);
      else Emit(_ILOAD, Index);
    end;
  end
  else if Typ = TPredefined.realType then begin
    case Index of
      0: Emit(_FLOAD_0);
      1: Emit(_FLOAD_1);
      2: Emit(_FLOAD_2);
      3: Emit(_FLOAD_3);
      else Emit(_FLOAD, Index);
    end;
  end
  else begin
    case Index of
      0: Emit(_ALOAD_0);
      1: Emit(_ALOAD_1);
      2: Emit(_ALOAD_2);
      3: Emit(_ALOAD_3);
      else Emit(_ALOAD, Index);
    end;
  end;
end;

//Emit code to load the value of a variable, which can be a program variable,
//a local variable, or a VAR parameter.
procedure TCodeGenerator.EmitLoadVariable(VariableID: ISymTabEntry);
var
  VariableType: ITypeSpec;
  NestingLevel, Slot: Integer;
  ProgName, VariableName, Name: String;
begin
  VariableType := VariableID.getTypeSpec.baseType;
  NestingLevel := VariableID.getSymTab.getNestingLevel;
  //program variable
  if NestingLevel = 1 then begin
    ProgName := SymTabStack.getProgramID.getName;
    VariableName := VariableID.getName;
    Name := ProgName + '/' + VariableName;
    Emit(_GETSTATIC, Name, TypeDescriptor(VariableType));
  end
  //wrapped variable
  else if isWrapped(VariableID) then begin
    Slot := TInteger(VariableID.getAttribute(skSlot)).Value;
    EmitLoadLocal(Nil, Slot);
    Emit(_GETFIELD, VarParmWrapper(VariableType) + '/value',
           TypeDescriptor(VariableType));
  end
  //local variable
  else begin
    Slot := TInteger(VariableID.getAttribute(skSlot)).Value;
    EmitLoadLocal(VariableType, Slot);
  end;
end;

//Emit a load of an array element.
procedure TCodeGenerator.EmitLoadArrayElement(elmtType: ITypeSpec);
var
  Form: ITypeForm;
begin
  Form := tfNone;
  if elmtType <> Nil then begin
    elmtType := elmtType.baseType;
    Form := elmtType.getForm;
  end;
  //load a character from a string
  if elmtType = TPredefined.charType then
    Emit(_INVOKEVIRTUAL, 'java/lang/StringBuilder.charAt(I)C')
  //load an array element
  else begin
    if elmtType = TPredefined.integerType then Emit(_IALOAD)
    else if elmtType = TPredefined.realType then Emit(_FALOAD)
    else if elmtType = TPredefined.booleanType then Emit(_BALOAD)
    else if elmtType = TPredefined.charType then Emit(_CALOAD)
    else if Form = tfEnumeration then Emit(_IALOAD)
    else Emit(_AALOAD);
  end;
end;

//Emit a store instruction into a local variable
procedure TCodeGenerator.EmitStoreLocal(Typ: ITypeSpec; Index: Integer);
var
  Form: ITypeForm;
begin
  Form := tfNone;
  if Typ <> Nil then begin
    Typ := Typ.baseType;
    Form := Typ.getForm;
  end;
  if (Typ = TPredefined.integerType) or (Typ = TPredefined.booleanType) or
     (Typ = TPredefined.charType) or (Form = tfEnumeration) then
  begin
    case Index of
      0: Emit(_ISTORE_0);
      1: Emit(_ISTORE_1);
      2: Emit(_ISTORE_2);
      3: Emit(_ISTORE_3);
      else Emit(_ISTORE, Index);
    end;
  end
  else if Typ = TPredefined.realType then begin
    case Index of
      0: Emit(_FSTORE_0);
      1: Emit(_FSTORE_1);
      2: Emit(_FSTORE_2);
      3: Emit(_FSTORE_3);
      else Emit(_FSTORE, Index);
    end;
  end
  else begin
    case Index of
      0: Emit(_ASTORE_0);
      1: Emit(_ASTORE_1);
      2: Emit(_ASTORE_2);
      3: Emit(_ASTORE_3);
      else Emit(_ASTORE, Index);
    end;
  end;
end;

//Emit code to store a value into a variable, which can be a program variable,
//a local variable, or a VAR parameter.
procedure TCodeGenerator.EmitStoreVariable(VariableID: ISymTabEntry);
var
  NestingLevel, Slot: Integer;
begin
  NestingLevel := VariableID.getSymTab.getNestingLevel;
  Slot := TInteger(VariableID.getAttribute(skSlot)).Value;
  EmitStoreVariable(VariableID, NestingLevel, Slot);
end;

procedure TCodeGenerator.EmitStoreVariable
  (VariableID: ISymTabEntry; NestingLevel, Index: Integer);
var
  VariableType: ITypeSpec;
  TargetName, ProgName, Name: String;
begin
  VariableType := VariableID.getTypeSpec;
  //program variable
  if NestingLevel = 1 then begin
    TargetName := VariableID.getName;
    ProgName := SymTabStack.getProgramID.getName;
    Name := ProgName + '/' + TargetName;
    EmitRangeCheck(VariableType);
    Emit(_PUTSTATIC, Name, TypeDescriptor(VariableType.baseType));
  end
  //wrapped parameter: set the wrapper's value field
  else if isWrapped(VariableID) then begin
    EmitRangeCheck(VariableType);
    Emit(_PUTFIELD, VarParmWrapper(VariableType.baseType) + '/value',
           TypeDescriptor(VariableType.baseType));
  end
  //local variable
  else begin
    EmitRangeCheck(VariableType);
    EmitStoreLocal(VariableType.baseType, Index);
  end;
end;

//emit a store of an array element
procedure TCodeGenerator.EmitStoreArrayElement(elmtType: ITypeSpec);
var
  Form: ITypeForm;
begin
  Form := tfNone;
  if elmtType <> Nil then begin
    elmtType := elmtType.baseType;
    Form := elmtType.getForm;
  end;
  if elmtType = TPredefined.charType then
    Emit(_INVOKEVIRTUAL, 'java/lang/StringBuilder.setCharAt(IC)V')
  else begin
    if elmtType = TPredefined.integerType then Emit(_IASTORE)
    else if elmtType = TPredefined.realType then Emit(_FASTORE)
    else if elmtType = TPredefined.booleanType then Emit(_BASTORE)
    else if elmtType = TPredefined.charType then Emit(_CASTORE)
    else if Form = tfEnumeration then Emit(_IASTORE)
    else Emit(_AASTORE);
  end;
end;

//Emit the CHECKCAST instruction for a scalar type
procedure TCodeGenerator.EmitCheckCast(Typ: ITypeSpec);
var
  Descriptor: String;
begin
  Descriptor := TypeDescriptor(Typ);
  //Don't bracket the type with L; if it's not an array
  if Descriptor[1] = 'L' then
    Descriptor := Copy(Descriptor, 2, Length(Descriptor)-1);
  Emit(_CHECKCAST, Descriptor);
end;

//Emit the CHECKCAST instruction for a class
procedure TCodeGenerator.EmitCheckCastClass(Typ: ITypeSpec);
var
  Descriptor: String;
begin
  Descriptor := javaTypeDescriptor(Typ);
  //Don't bracket the type with L; if it's not an array
  if Descriptor[1] = 'L' then
    Descriptor := Copy(Descriptor, 2, Length(Descriptor)-1);
  Emit(_CHECKCAST, Descriptor);
end;

//Emit a function return of a value
procedure TCodeGenerator.EmitReturnValue(Typ: ITypeSpec);
var
  Form: ITypeForm;
begin
  Form := tfNone;
  if Typ <> Nil then begin
    Typ := Typ.baseType;
    Form := Typ.getForm;
  end;
  if (Typ = TPredefined.integerType) or (Typ = TPredefined.booleanType) or
     (Typ = TPredefined.charType) or (Form = tfEnumeration) then
    Emit(_IRETURN)
  else if Typ = TPredefined.realType then
    Emit(_FRETURN)
  else
    Emit(_ARETURN)
end;

//Emit code to perform a runtime range check before an assignment.
procedure TCodeGenerator.EmitRangeCheck(TargetType: ITypeSpec);
var
  Min, Max: Integer;
begin
  if TargetType.getForm = tfSubRange then begin
    Min := TInteger(TargetType.getAttribute(tkSubRangeMinValue)).Value;
    Max := TInteger(TargetType.getAttribute(tkSubRangeMaxValue)).Value;
    Emit(_DUP);
    EmitLoadConstant(Min);
    EmitLoadConstant(Max);
    Emit(_INVOKESTATIC, 'RangeChecker/check(III)V');

    LocalStack.Use(3);
  end;
end;

//Generate a type descriptor of an identifier's type
function TCodeGenerator.TypeDescriptor(ID: ISymTabEntry): String;
var
  Typ: ITypeSpec;
begin
 Typ := ID.getTypeSpec;
 if Typ <> Nil then begin
   if isWrapped(ID) then
     Result := 'L' + VarParmWrapper(Typ.baseType) + ';'
   else
     Result := TypeDescriptor(ID.getTypeSpec)
 end
 else
   Result := 'V';
end;

//Generate a type descriptor data type
function TCodeGenerator.TypeDescriptor(Typ: ITypeSpec): String;
var
  Form: ITypeForm;
  Buffer: TString;
begin
  Form := Typ.getForm;
  Buffer := TString.Create;
  while (Form = tfArray) and not Typ.isPascalString do begin
    Buffer.Append('[');
    Typ := Typ.getAttribute(tkArrayElementType) as ITypeSpec;
    Form := Typ.getForm;
  end;
  Typ := Typ.baseType;
  if Typ = TPredefined.integerType then
    Buffer.Append('I')
  else if Typ = TPredefined.realType then
    Buffer.Append('F')
  else if Typ = TPredefined.booleanType then
    Buffer.Append('Z')
  else if Typ = TPredefined.charType then
    Buffer.Append('C')
  else if Typ.isPascalString then
    Buffer.Append('Ljava/lang/StringBuilder;')
  else if Form = tfEnumeration then
    Buffer.Append('I')
  else if Form = tfRecord then
    Buffer.Append('Ljava/util/HashMap;');
  Result := Buffer.toString;
end;

//Generate a java type descriptor for a data type.
function TCodeGenerator.javaTypeDescriptor(Typ: ITypeSpec): String;
var
  Form: ITypeForm;
  Buffer: TString;
  isArray: Boolean = False;
begin
  Form := Typ.getForm;
  Buffer := TString.Create;
  while (Form = tfArray) and not Typ.isPascalString do begin
    Buffer.Append('[');
    Typ := Typ.getAttribute(tkArrayElementType) as ITypeSpec;
    Form := Typ.getForm;
    isArray := True;
  end;
  if isArray then
    Buffer.Append('L');

  Typ := Typ.baseType;
  if Typ = TPredefined.integerType then
    Buffer.Append('java/lang/Integer')
  else if Typ = TPredefined.realType then
    Buffer.Append('java/lang/Float')
  else if Typ = TPredefined.booleanType then
    Buffer.Append('java/lang/Boolean')
  else if Typ = TPredefined.charType then
    Buffer.Append('java/lang/Character')
  else if Typ.isPascalString then
    Buffer.Append('java/lang/StringBuilder;')
  else if Form = tfEnumeration then
    Buffer.Append('java/lang/Integer')
  else //if Form = tfRecord then
    Buffer.Append('java/util/HashMap;');
  if isArray then
    Buffer.Append(';');
  Result := Buffer.toString;
end;

//Return whether or not a data type is structured
function TCodeGenerator.isStructured(Typ: ITypeSpec): Boolean;
var
  Form: ITypeForm;
begin
  Form := Typ.getForm;
  Result := Typ.isPascalString or (Form = tfArray) or (Form = tfRecord);
end;

//Return whether or not a variable is wrapped to pass by reference
function TCodeGenerator.isWrapped(VariableID: ISymTabEntry): Boolean;
var
  Typ: ITypeSpec;
  Form: ITypeForm;
  Defn: IDefinition;
begin
  Typ := VariableID.getTypeSpec;
  Form := Typ.getForm;
  Defn := VariableID.getDefinition;
  //Arrays and records are not wrapped
  Result := (Defn = defVAR_PARM) and (Form <> tfArray) and (Form <> tfRecord);
end;

//Return whether or not a variable needs to be cloned to pass by value.
function TCodeGenerator.needsCloning(FormalID: ISymTabEntry): Boolean;
var
  Typ: ITypeSpec;
  Form: ITypeForm;
  Defn: IDefinition;
begin
  Typ := FormalID.getTypeSpec;
  Form := Typ.getForm;
  Defn := FormalID.getDefinition;
  //Arrays and records are normally passed by reference
  //and so must be cloned to be passed by value.
  Result := (Defn = defVALUE_PARM) and ((Form <> tfArray) or (Form <> tfRecord));
end;

//return the valueOf() signature for a given scalar type
function TCodeGenerator.ValueOfSignature(Typ: ITypeSpec): String;
var
  javaType, TypeCode: String;
begin
  javaType := javaTypeDescriptor(Typ);
  TypeCode := TypeDescriptor(Typ);
  Result := Format('%s.valueOf(%s)L%s', [javaType, TypeCode, javaType]);
end;

//return the xxxValue() signature for a given scalar type
function TCodeGenerator.ValueSignature(Typ: ITypeSpec): String;
var
  javaType, TypeCode, TypeName: String;
begin
  javaType := javaTypeDescriptor(Typ);
  TypeCode := TypeDescriptor(Typ);
  if Typ = TPredefined.integerType then TypeName := 'int'
  else if Typ = TPredefined.realType then TypeName := 'float'
  else if Typ = TPredefined.booleanType then TypeName := 'boolean'
  else if Typ = TPredefined.charType then TypeName := 'char'
  else TypeName := 'int';
  Result := Format('%s.%sValue()%s', [javaType, TypeName, TypeCode]);
end;

//Generate the name of the wrapper to use to pass an actual parameter by reference.
function TCodeGenerator.VarParmWrapper(Typ: ITypeSpec): String;
var
  Form: ITypeForm;
begin
  Typ := Typ.baseType;
  Form := Typ.getForm;
  if Typ = TPredefined.integerType then
    Result := 'IWRAP'
  else if Typ = TPredefined.realType then
    Result := 'RWRAP'
  else if Typ = TPredefined.booleanType then
    Result := 'BWRAP'
  else if Form = tfEnumeration then
    Result := 'IWRAP'
  else
    Result := 'CWRAP';
end;



end.

