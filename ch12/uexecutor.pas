unit uExecutor;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, uBaseScanner, uPascalScanner, uSource, uTextReader,
  ubackend, dateutils, ucode, uCodeImpl, uGenericInterfaces, umessages,
  uRuntimeErrorHandler, uMemoryFactory, uMemory, uCodeFactory, fgl, uObjectUtils;

type

  TCellList = specialize TFPGList<ICell>;

  { TExecutor }

  TExecutor = class(TBackEnd)
    protected
      class var
        ExecutionCount: integer;
        RuntimeStack: IRuntimeStack;
        ErrorHandler: TRuntimeErrorHandler;
        StandardIn: TBaseScanner;
        //StandardOut: TStream;
    public
      //class constructor Create;
      constructor Create;
      constructor Create(Parent: TExecutor);
      //destructor Destroy;
      function getErrorHandler: TRuntimeErrorHandler;
      procedure Process(AiCode: IIntermediateCode;
        ASymtabStack: ISymtabStack); override;
  end;

implementation
uses uExecutors;

{ TCodeGenerator }

{class constructor TExecutor.Create;
begin
  ExecutionCount := 0;
  RuntimeStack := TMemoryFactory.CreateRuntimeStack;
  ErrorHandler := TRuntimeErrorHandler.Create;
  StandardIn := TPascalScanner.Create(
    TSource.Create(TTextReader.Create(THandleStream.Create(StdInputHandle)))
  );

  //StandardOut := THandleStream.Create(StdOutputHandle);
end;
}
constructor TExecutor.Create;
begin
  //Inherited Create;
end;

constructor TExecutor.Create(Parent: TExecutor);
begin
  Inherited Create;
end;

{destructor TExecutor.Destroy;
begin
  if assigned(StandardIn) then StandardIn.Free;
end; }

function TExecutor.getErrorHandler: TRuntimeErrorHandler;
begin
  Result := errorHandler;
end;

// Execute the source program by
// processing the intermediate code and the symbol table generated by the
// parser..
procedure TExecutor.Process
  (AiCode: IIntermediateCode; ASymtabStack: ISymtabStack);
var
  StartTime: TDateTime;
  ElapsedTime: Double;
  ProgramID: ISymTabEntry;
  CallNode: ICodeNode;
  RuntimeErrors: integer;
  CallExecutor: TCallDeclaredExecutor;
begin
  SymTabStack := ASymTabStack;
  StartTime := TimeOf(Now);

  ProgramID := SymTabStack.getProgramID;

  //Construct an artificial CALL node to the main program
  CallNode := TICodeFactory.CreateICodeNode(ctCall);
  CallNode.setAttribute(ckID, ProgramID.getObject);

  //Execute the main program
  CallExecutor := TCallDeclaredExecutor.Create(Self);
  CallExecutor.Execute(CallNode);

  ElapsedTime := SecondSpan(StartTime, TimeOf(Now));

  runtimeErrors := errorHandler.getErrorCount;

  SendMessage(TMessage.Create(mtInterpreterSummary,
    TInterpreterSummaryMsg.Create(ExecutionCount, RuntimeErrors, ElapsedTime)));

end;

Initialization
  TExecutor.ExecutionCount := 0;
  TExecutor.RuntimeStack := TMemoryFactory.CreateRuntimeStack;
  TExecutor.ErrorHandler := TRuntimeErrorHandler.Create;
  TExecutor.StandardIn := TPascalScanner.Create(
    TSource.Create(TTextReader.Create(THandleStream.Create(StdInputHandle)))
  );

Finalization
  TExecutor.ErrorHandler.Free;
  TExecutor.StandardIn.Free;
end.

