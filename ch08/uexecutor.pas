unit uExecutor;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils,
  ubackend, dateutils, ucode, usymtab, umessages, uRuntimeErrorHandler;

type

  { TExecutor }

  TExecutor = class(TBackEnd)
    protected
      class var executionCount: integer;
      class var errorHandler: TRuntimeErrorHandler;
    public
      class constructor Create;
      constructor Create;
      constructor Create(Parent: TExecutor);
      function getErrorHandler: TRuntimeErrorHandler;
      procedure Process(AiCode: IIntermediateCode;
        ASymtabStack: ISymtabStack); override;
  end;

implementation
uses uExecutors;

{ TCodeGenerator }

class constructor TExecutor.Create;
begin
  executionCount := 0;
  errorHandler := TRuntimeErrorHandler.Create;
end;

constructor TExecutor.Create;
begin
  //Inherited Create;
end;

constructor TExecutor.Create(Parent: TExecutor);
begin
  Inherited Create;
end;

function TExecutor.getErrorHandler: TRuntimeErrorHandler;
begin
  Result := errorHandler;
end;

// Execute the source program by
// processing the intermediate code and the symbol table generated by the
// parser..
procedure TExecutor.Process(AiCode: IIntermediateCode;
  ASymtabStack: ISymtabStack);
var
  StartTime: TDateTime;
  ElapsedTime: Double;
  rootNode: ICodeNode;
  runtimeErrors: integer;
  statementExecutor: TStatementExecutor;
begin
  symtabStack := ASymtabStack;
  iCode := AiCode;

  StartTime := TimeOf(Now);

  //get the root node of the intermediate code and execute
  rootNode := iCode.getRoot;
  statementExecutor := TStatementExecutor.Create(Self);
  statementExecutor.Execute(rootNode);

  ElapsedTime := SecondSpan(StartTime, TimeOf(Now));

  runtimeErrors := errorHandler.getErrorCount;

  SendMessage(TMessage.Create(mtInterpreterSummary,
    TInterpreterSummaryMsg.Create(ExecutionCount, RuntimeErrors, ElapsedTime)));

end;



end.

